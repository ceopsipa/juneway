**1. Опишите, что происходит, при выполнении любой команды в консоли, например: `$ ls -l`**

Создается форк (клонирование) процесса и запускается команда `$ ls -l`, родительский процесс запускает сигнал wait, ждет пока форкнутый процесс корректно завершится. После того как команда отработала в форкнутом процессе, программа использует системный вызов exit и посылает сигнал SIGCHLD родительскому процессу. После этого форкнутый процесс изчезает и остается лишь родительский процесс.

**2. Используя ключ 'o', выведите с помощью `ps` список всех процессов в таком формате: `PID USER %CPU VSZ TT COMMAND` пояснение: ID процесса, пользователь (real user), % загрузки CPU, размер виртуальной памяти, управляющий терминал, команда. прикрепите вывод к задаче, перенаправив вывод на `head`: `$ ps ... ваши опции ... | head`**

```sh
root@experemental:~# ps ax -o pid,user,%cpu,vsz,tt,command|head
  PID USER     %CPU    VSZ TT       COMMAND
    1 root      0.3 103708 ?        /sbin/init nofb
    2 root      0.0      0 ?        [kthreadd]
    3 root      0.0      0 ?        [rcu_gp]
    4 root      0.0      0 ?        [rcu_par_gp]
    6 root      0.0      0 ?        [kworker/0:0H-kblockd]
    7 root      0.0      0 ?        [kworker/u2:0-events_unbound]
    8 root      0.0      0 ?        [mm_percpu_wq]
    9 root      0.0      0 ?        [ksoftirqd/0]
   10 root      0.0      0 ?        [rcu_sched]
```
**3. Создайте процесс sleep с помощью `$ sleep infinity &`**

```sh
sleep infinity &
ps ax|grep infinity
kill -9 663
ps ax|grep infinity
```